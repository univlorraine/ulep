datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

model User {
  id                    String              @id
  email                 String              @unique
  profile               Profile?
  reports               Report[]

  @@map("users")
}

model Profile {
  id                    String              @id @default(uuid())
  user                  User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId                String              @unique
  firstname             String
  lastname              String
  age                   Int
  gender                String
  role                  String
  metadata              Json // availability, goals, meetingFrequency, department, diploma, bio, interests, etc.
  university            University          @relation(fields: [universityId], references: [id], onDelete: Cascade)
  universityId          String
  nationality           Country             @relation(fields: [nationalityId], references: [id])
  nationalityId         String
  avatar                MediaObject?
  nativeLanguage        Language            @relation("NativeLanguage", fields: [nativeLanguageCode], references: [code])
  nativeLanguageCode    String
  learningLanguage      Language            @relation("LearningLanguage", fields: [learningLanguageCode], references: [code])
  learningLanguageCode  String
  learningLanguageLevel String
  masteredLanguages     MasteredLanguage[]
  preferences           LearningPreference? @relation(fields: [preferencesId], references: [id])
  preferencesId         String?             @unique
  tandems               ProfilesOnTandems[]
  createdAt             DateTime            @default(now())

  @@map("profiles")
  @@index([nativeLanguageCode], name: "native_language_code")
  @@index([learningLanguageCode], name: "learning_language_code")
  @@index([universityId], name: "university_id")
}

model Language {
  code                  String              @id
  name                  String
  isAvailable           Boolean
  nativeSpeakers        Profile[]           @relation("NativeLanguage")
  learningUsers         Profile[]           @relation("LearningLanguage")
  masteredByUsers       MasteredLanguage[]

  @@map("languages")
}

// Many to many relation between Profile and Language
model MasteredLanguage {
  profileId             String
  languageCode          String
  profile               Profile             @relation(fields: [profileId], references: [id])
  language              Language            @relation(fields: [languageCode], references: [code])

  @@id([profileId, languageCode])
  @@map("mastered_languages")
}

model LearningPreference {
  id                    String              @id @default(uuid())
  sameGender            Boolean
  remote                Boolean             @default(true)
  profile               Profile?
  // TODO: meetingFrequency, goals, etc.

  @@map("learning_preferences")
}

model Country {
  id                    String              @id @default(uuid())
  code                  String              @unique
  name                  String
  profiles              Profile[]
  universities          University[]
  createdAt             DateTime            @default(now())

  @@map("countries")
}

model University {
  id                    String              @id @default(uuid())
  profiles              Profile[]
  name                  String              @unique
  country               Country             @relation(fields: [countryId], references: [id])
  countryId             String
  timezone              String
  admissionStart        DateTime
  admissionEnd          DateTime
  createdAt             DateTime            @default(now())

  @@map("universities")
}

model Tandem {
  id                    String              @id @default(uuid())
  startDate             DateTime
  endDate               DateTime
  profiles              ProfilesOnTandems[]

  @@map("tandems")
}

model ProfilesOnTandems {
  profile               Profile            @relation(fields: [profileId], references: [id], onDelete: Cascade)
  profileId             String
  tandem                Tandem             @relation(fields: [tandemId], references: [id], onDelete: Cascade)
  tandemId              String

  @@id([profileId, tandemId])
  @@map("profiles_on_tandems")
}

model MediaObject {
  id                    String              @id @default(uuid())
  name                  String
  bucket                String
  mime                  String
  size                  Int
  createdAt             DateTime            @default(now())
  profile               Profile             @relation(fields: [profileId], references: [id], onDelete: Cascade)
  profileId             String              @unique

  @@map("media_objects")
}

model Report {
  id                    String              @id @default(uuid())
  content               String
  categoryId            String
  userId                String
  category              ReportCategory      @relation(fields: [categoryId], references: [id])
  user                  User                @relation(fields: [userId], references: [id])
  createdAt             DateTime            @default(now())
  updatedAt             DateTime            @updatedAt

  @@map("reports")
}

model ReportCategory {
  id                    String              @id @default(uuid())
  name                  String              @unique
  reports               Report[]            // Category to Reports relation, one category can have many reports

  @@map("report_categories")
}